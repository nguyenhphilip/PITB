library(tidyverse)
d %>% glimpse()
'
fit <- cfa(Hs.model, data = d)
speed =~ x7 + x8 + x9'
# syntax for our latent variable model with three latent factors, each defined by three indicators
Hs.model <-
'visual =~ x1 + x2 + x3
speed =~ x7 + x8 + x9'
# syntax for our latent variable model with three latent factors, each defined by three indicators
Hs.model <- 'visual =~ x1 + x2 + x3
Hs.model <- 'visual =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed =~ x7 + x8 + x9'
speed =~ x7 + x8 + x9'
Hs.model <- '
speed =~ x7 + x8 + x9 '
Hs.model <- ' visual =~ x1 + x2 + x3
Hs.model <- 'visual =~ x1 + x2 + x3 textual =~ x4 + x5 + x6 speed =~ x7 + x8 + x9'
fit <- cfa(Hs.model, data = d)
Hs.model <- 'visual =~ x1 + x2 + x3 textual =~ x4 + x5 + x6 speed =~ x7 + x8 + x9'
fit <- cfa(Hs.model, data = d)
Hs.model <- ' visual =~ x1 + x2 + x3 textual =~ x4 + x5 + x6 speed =~ x7 + x8 + x9 '
fit <- cfa(Hs.model, data = d)
speed =~ x7 + x8 + x9 '
Hs.model <- ' visual =~ x1 + x2 + x3 textual =~ x4 + x5 + x6
Hs.model <- ' visual =~ x1 + x2 + x3 textual =~ x4 + x5 + x6
speed =~ x7 + x8 + x9 '
fit <- cfa(Hs.model, data = d)
'
Hs.model <- '
# latent variables
visual =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed =~ x7 + x8 + x9
'
fit <- cfa(Hs.model, data = d)
Hs.model <- '
# latent variables
visual =~ x1 + x2 + x3
textual =~ x4 + x5 + x6
speed =~ x7 + x8 + x9
'
Hs.model
fit <- cfa(Hs.model, data = d)
fit
summary(fit)
summary(fit)
library(tidyverse)
library(here)
library(broom)
library(skimr)
library(readxl)
library(formattable)
options(scipen = 999)
# set seed for reproducibility - ensures results are the same each time script is run
set.seed(100)
# Formula:
MatchIt::matchit(premature_category ~ interview_age + demo_sex_v2 + ehi_y_ss_scoreb + average_puberty + scanner_num + combined_income_cat + highest_ed_category + race_ethnicity + twin_sib_status, data = dropped_premat_cov, method = "nearest", ratio = 3)
# MATCHING
# Groupings made using MatchIt package - 3:1 Full term:premature ratio.
# Matched to closest match on:
# age, sex, handedness,
# average puberty, scanner,
# combined income class, highest household education, race,
# and twin status
install.packages("MatchIt")
# set seed for reproducibility - ensures results are the same each time script is run
set.seed(100)
# LOAD AND CLEAN DATA
post_strat <- read_csv("../2.0_ABCD_Data_Explorer/2-0and2-0-1/ABCD ACS Post Stratification Weights.csv") %>%
filter(eventname == "baseline_year_1_arm_1") %>% select(src_subject_id, rel_relationship)
libary(mvnorm)
library(mvnorm)
mu <- c(10, 5)
sigma <- matrix(data = c(1,2, 5, 4))
sigma
sigma <- matrix(data = c(1,2, 5, 4), nrow = 2)
sigma
n <- 100
MASS::mvrnorm(n, mu, sigma)
mu <- c(0, 0)
n <- 100
# simulate standard normal
mu <- c(0, 0)
# Since the standard deviations of each distribution are 1
# the covariance matrix is equivalent to the correlation matrix.
sigma <- matrix(data = c(1, 0.15,
0.15, 1), nrow = 2)
sigma
MASS::mvrnorm(n, mu, sigma)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble()
library(tidyverse)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble()
d
MASS::mvrnorm(n, mu, sigma)
y = `V2')
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
d
cor(d)
n <- 100
# simulate standard normal
mu <- c(0, 0)
# Since the standard deviations of each distribution are 1
# the covariance matrix is equivalent to the correlation matrix.
sigma <- matrix(data = c(1, 0.15,
0.15, 1), nrow = 2)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
cor(d)
set.seed(5)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
cor(d)
corrr::correlate(d)
corrr::correlate(d) |>
shave()
library(corrr)
correlate(d) |>
shave()
correlate(d) |>
shave() |>
fashion()
correlate(d) |>
shave() |>
fashion() |>
rmarkdown::paged_table()
lm(y ~ x, data = d) |> summary()
mod <- lm(y ~ x, data = d)
mod |> predict()
y_pred <- mod |> predict()
d |>
cbind(y_pred)
d <- d |>
cbind(y_pred)
d <- d |>
# cbind(y_pred) |>
mutate(residuals = (y_pred - y)^2)
d
d |>
ggplot(aes(x = residuals)) |>
geom_histogram()
d |>
ggplot(aes(x = residuals)) +
geom_histogram()
d <- d |>
cbind(y_pred) |>
mutate(residuals = (y_pred - y))
d |>
ggplot(aes(x = residuals)) +
geom_histogram()
d |>
ggplot(aes(x = sqrt(residuals))) +
geom_histogram()
qqplot(d$y, d$y_pred)
d |>
ggplot(aes(x = x, y = residuals)) +
geom_histogram()
d |>
ggplot(aes(x = x, y = residuals)) +
geom_point()
d <- d |>
cbind(y_pred) |>
mutate(residuals = (y_pred - y)^2)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
correlate(d) |>
shave() |>
fashion() |>
rmarkdown::paged_table()
mod <- lm(y ~ x, data = d)
y_pred <- mod |> predict()
d <- d |>
cbind(y_pred) |>
mutate(residuals = (y_pred - y)^2)
d |>
ggplot(aes(x = x, y = residuals)) +
geom_point()
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
correlate(d) |>
shave() |>
fashion() |>
rmarkdown::paged_table()
mod <- lm(y ~ x, data = d)
y_pred <- mod |> predict()
d <- d |>
cbind(y_pred) |>
mutate(residuals = (y_pred - y))
d |>
ggplot(aes(x = x, y = residuals)) +
geom_point()
d |>
ggplot(aes(x = y_pred, y = residuals)) +
geom_point()
d |>
ggplot(aes(x = y_pred, y = residuals)) +
geom_point()
d |>
ggplot(aes(x = y_pred, y = residuals)) +
geom_point() +
geom_hline(yintercept = 0) +
labs(title = "Fitted values against residuals")
?qqplot()
qqplot(d$y)
qqplot(d$y, d)
qqplot(d$y, d$x)
qqplot(d$y, d$y_pred)
qqplot(d$residuals, d$y_pred)
qqline(d$y)
qqline(d$y)
qplot(y, data = d)
qplot(sample = y, data = d)
qplot(sample = y, data = d) +
stat_qq()
qplot(sample = y, data = d) +
labs(x = "theoretical", y = "sample y")
qplot(sample = y, data = d) +
labs(x = "theoretical", y = "sample y", title = "QQ Plot")
qplot(sample = x, data = d) +
labs(x = "theoretical", y = "sample y", title = "QQ Plot")
qplot(sample = y, data = d) +
labs(x = "theoretical", y = "sample y", title = "QQ Plot")
d |>
ggplot(aes(x = y_pred, y = residuals)) +
geom_point()
mod
mod |>
summary()
set.seed(5)
n <- 100
# simulate standard normal
mu <- c(0, 0)
# Since the standard deviations of each distribution are 1
# the covariance matrix is equivalent to the correlation matrix.
sigma <- matrix(data = c(1, 0.15,
0.15, 1), nrow = 2)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
correlate(d) |>
shave() |>
fashion() |>
rmarkdown::paged_table()
mod <- lm(y ~ x, data = d)
y_pred <- mod |> predict()
d <- d |>
cbind(y_pred) |>
mutate(residuals = (y_pred - y))
d |>
ggplot(aes(x = y_pred, y = residuals)) +
geom_point() +
geom_hline(yintercept = 0) +
labs(title = "Fitted values against residuals")
qplot(sample = y, data = d) +
labs(x = "theoretical", y = "sample y", title = "QQ Plot")
mod |>
summary()
d |>
ggplot(aes(x = x, y = y)) +
geom_point()
d |>
ggplot(aes(x = x, y = y)) +
geom_point() +
geom_smooth(method = "lm")
correlate(d) |>
shave() |>
fashion() |>
rmarkdown::paged_table()
n <- 10000
# simulate standard normal
mu <- c(0, 0)
# Since the standard deviations of each distribution are 1
# the covariance matrix is equivalent to the correlation matrix.
sigma <- matrix(data = c(1, 0.15,
0.15, 1), nrow = 2)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
correlate(d) |>
shave() |>
fashion() |>
rmarkdown::paged_table()
lm(y ~ x, data = d)
<- lm(y ~ 0 +x, data = d) |>
lm(y ~ 0 + x, data = d) |>
```
lm(y ~ x, data = d) |>
```
lm(y ~ x, data = d) |>
summary()
n <- 100000
# simulate standard normal
mu <- c(0, 0)
n <- 100000
# simulate standard normal
mu <- c(0, 0)
# Since the standard deviations of each distribution are 1
# the covariance matrix is equivalent to the correlation matrix.
sigma <- matrix(data = c(1, 0.15,
0.15, 1), nrow = 2)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
correlate(d) |>
shave() |>
fashion() |>
rmarkdown::paged_table()
lm(y ~ x, data = d) |>
summary()
mod |>
summary() |>
tidy()
mod |>
tidy()
mod |>
broom:;tidy()
mod |>
broom::tidy()
mod |>
broom::tidy() |>
round(3)
mod |>
broom::tidy() |>
mutate(across(where(is.numeric), ~round(2)))
mod |>
broom::tidy() |>
mutate(across(where(is.numeric), ~round(3)))
mod |>
broom::tidy() |>
mutate(across(where(is.numeric), ~round(.x, 3)))
lm(y ~ x, data = d) |>
summary() >
broom::tidy() |>
mutate(across(where(is.numeric), ~round(.x, 3)))
lm(y ~ x, data = d) |>
summary() >
broom::tidy() |>
mutate(across(where(is.numeric), ~round(.x, 3)))
lm(y ~ x, data = d) |>
broom::tidy() |>
mutate(across(where(is.numeric), ~round(.x, 3)))
correlate(d) |>
shave() |>
rmarkdown::paged_table()
n <- 100
# simulate standard normal
mu <- c(0, 0)
# Since the standard deviations of each distribution are 1
# the covariance matrix is equivalent to the correlation matrix.
sigma <- matrix(data = c(1, 0.15,
0.15, 1), nrow = 2)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
correlate(d) |>
shave() |>
rmarkdown::paged_table()
set.seed(5)
n <- 100
# simulate standard normal
mu <- c(0, 0)
# Since the standard deviations of each distribution are 1
# the covariance matrix is equivalent to the correlation matrix.
sigma <- matrix(data = c(1, 0.15,
0.15, 1), nrow = 2)
d <- MASS::mvrnorm(n, mu, sigma) |>
as_tibble() |>
rename(x = `V1`,
y = `V2`)
correlate(d) |>
shave() |>
rmarkdown::paged_table()
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
# fig.align = "center",
fig.width = 8,
fig.height = 4,
dev = "png",
cache = TRUE)
d <- vroom("~/Desktop/PhD/resilience-im-burt/resil_grouped_data.csv") |>
mutate(class = factor(class,
levels = c("competent",
"resilient",
"vulnerable",
"maladaptive")),
pds_cat = factor(pds_cat),
sex = factor(sex),
recruitment_centre = factor(recruitment_centre),
all_handedness = factor(all_handedness),
# mean center continuous covariates
pds_sum_c = center(pds_sum),
v_iq_c = center(v_iq),
p_iq_c = center(p_iq),
age_years_bsl_c = center(age_years_bsl),
# for ordered probit
across(contains("alcohol"), ~ factor(.x, ordered = T, exclude = NA)),
across(contains("mj_hash_"), ~ factor(.x, ordered = T, exclude = NA)),
across(contains("cigs_"), ~ factor(.x, ordered = T, exclude = NA)),
across(`8a_bsl`:`21_bsl`, ~ factor(.x, ordered = T, exclude = NA)),
across(`8a_fu1`:`21_fu1`, ~ factor(.x, ordered = T, exclude = NA)),
across(`8a_fu2`:`21_fu2`, ~ factor(.x, ordered = T, exclude = NA)),
across(`8a_fu3`:`21_fu3`, ~ factor(.x, ordered = T, exclude = NA)),
sex = case_when(sex == 1 ~ "Male",
sex == 2 ~ "Female"),
all_handedness = case_when(all_handedness == 0 ~ "Left",
all_handedness == 1 ~ "Right"),
# standardize sum score outcomes
audit_total_score_fu3 = standardize(audit_total_score_fu3),
cesd_c_sum_fu3 = standardize(cesd_c_sum_fu3),
dawba_sdq_c_sebdtot_fu3 = standardize(dawba_sdq_c_sebdtot_fu3),
externalizing_fu3 = standardize(externalizing_fu3),
internalizing_fu3 = standardize(internalizing_fu3),
pss_c_sum_fu3 = standardize(pss_c_sum_fu3),
rapi_c_sum_fu3 = standardize(rapi_c_sum_fu3)
)
hyp_tds <- hyp("dawba_sdq_c_sebdtot_fu3", med_tds)
num_ratings <- c(600, 738, 380, 72, 28)
ratings <- seq(1, 5)
ratings <- seq(1, 5, -1)
ratings <- seq(1, 5, by=-1)
ratings <- seq(5,1)
(ratings*num_ratings)
sum((ratings*num_ratings))/sum(num_ratings)
expand(num_ratings,ratings)
expand.grid(num_ratings,ratings)
expectation <- c(0.33 * 5, 0.40 * 4, 0.20 * 3, 0.03 *2, 0.01 * 1)
sum(expectation)
e_sum <- sum(expectation)
rep(ratings)
rep(ratings, num_ratings)
mean(rep(ratings, num_ratings))
avg <- mean(rep(ratings, num_ratings))
median <- median(rep(ratings, num_ratings))
median
mode(rep(ratings, num_ratings))
spec <- 0.999 # p(T+|HIV+)
sens <- 0.999 # p(T-|HIV-)
inf_rate <- 0.0001
spec <- 0.999 # p(T+|HIV+)
sens <- 0.999 # p(T-|HIV-)
bayes <- (spec * inf_rate)/((spec * inf_rate) + ((1-sens)*(1-inf_rate)))
bayes <- (spec * inf_rate)/((spec * inf_rate) + ((1-sens)*(1-inf_rate)))
spec <- 0.9999 # p(T+|HIV+)
sens <- 0.9999 # p(T-|HIV-)
inf_rate <- 0.0001 # p(HIV+)
bayes <- (spec * inf_rate)/((spec * inf_rate) + ((1-sens)*(1-inf_rate)))
p_inf_pos <- (spec * inf_rate)/((spec * inf_rate) + ((1-sens)*(1-inf_rate)))
p_inf_pos <- function(spec, sens, inf_rate){
bayes <- (spec * inf_rate)/((spec * inf_rate) + ((1-sens)*(1-inf_rate)))
bayes
}
p_inf_pos(spec, sens, inf_rate)
p_inf_pos(spec, sens, inf_rate)
inf_rate <- 0.100 # p(HIV+)
p_inf_pos(spec, sens, inf_rate)
people <- 10000
people*inf_rate
people*(1-inf_rate)
num_inf_true <- (people*inf_rate)
num_inf_false <- people*(1-inf_rate)
inf_rate <- 0.0001 # p(HIV+)
people <- 10000
num_inf_true <- (people*inf_rate)
num_inf_false <- people*(1-inf_rate)
num_inf_true
num_inf_false
num_inf_false * spec
num_inf_false-(num_inf_false * spec)
num_inf_false
(num_inf_false * spec)
num_inf_false - (num_inf_false * spec)
num_inf_true
fp <- num_inf_false - (num_inf_false * spec)
num_inf_true / (num_inf_true + fp)
p_hiv_pos <- num_inf_true / (num_inf_true + fp)
people <- 100000
num_inf_true <- (people*inf_rate)
num_inf_false <- people*(1-inf_rate)
fp <- num_inf_false - (num_inf_false * spec)
p_hiv_pos <- num_inf_true / (num_inf_true + fp)
p_hiv_pos
install.packages("acs")
library(acs)
library(tidyverse)
acs::summary()
acs::cpi
pre <- c(0,1,3,2,3,1,2,3,0,0,0,0,1,2,3,4)
post <- c(1,0,2,1,1,1,1,2,0,0,0,0,1,1,1,2)
t.test(post-pre)
plot(pre)
